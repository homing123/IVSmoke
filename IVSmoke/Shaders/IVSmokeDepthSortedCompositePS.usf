// IVSmokeDepthSortedCompositePS.usf
// Depth-Sorted Composite using CustomDepth
// Compares smoke depth with particle CustomDepth to determine front/back ordering

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "/Engine/Private/ScreenPass.ush"
#include "/Engine/Private/DeferredShadingCommon.ush"

//~==============================================================================
// Input Textures

// Smoke layer (from ray marching CS)
Texture2D SmokeAlbedoTex;
Texture2D SmokeMaskTex;

// Particle layer (from Separate Translucency)
Texture2D SeparateTranslucencyTex;

// Samplers
SamplerState PointClamp_Sampler;
SamplerState LinearClamp_Sampler;

//~==============================================================================
// Viewport - Texture Extents for UV calculation

// Texture Extents (UV = SvPosition / TexExtent)
float2 SmokeTexExtent;

// Sharpness filter (matching TranslucencyComposite)
float Sharpness;

float4 InvDeviceZToWorldZTransform;

//~==============================================================================
// Helper Functions

/**
 * Check if CustomDepth contains valid data at this pixel.
 * Invalid data is typically at far plane (0.0 in reversed-Z) or unwritten.
 */
bool HasValidCustomDepth(float CustomDeviceZ)
{
	// In reversed-Z: 0.0 = far plane (invalid), values > 0 = valid
	return CustomDeviceZ > 0.0001 && CustomDeviceZ < 0.9999;
}

//~==============================================================================
// Main Depth-Sorted Composite Pixel Shader

void MainPS(
	float4 SvPosition : SV_POSITION,
	out float4 OutColor : SV_Target0)
{
	//~======================================================================
	// UV Calculation - Extent based
	// UV = SvPosition / TexExtent (direct texel-to-UV mapping)

	float2 SmokeUV = SvPosition.xy / SmokeTexExtent;

	// Get actual texture dimensions for accurate UV (CL 277 style)
	uint TranslucencyWidth, TranslucencyHeight;
	SeparateTranslucencyTex.GetDimensions(TranslucencyWidth, TranslucencyHeight);
	float2 TranslucencyUV = SvPosition.xy / float2(TranslucencyWidth, TranslucencyHeight);

	//~======================================================================
	// Sample Input Textures with Sharpness Filtering

	// Texel size for filtering
	float2 TexelSize = 2.0f / SmokeTexExtent;

	// Sample center values
	float4 smokeAlbedoCenter = SmokeAlbedoTex.Sample(LinearClamp_Sampler, SmokeUV);
	float2 smokeMaskCenter = SmokeMaskTex.Sample(LinearClamp_Sampler, SmokeUV).rg;

	// Apply Sharpness filter (matching TranslucencyComposite)
	float4 filteredSmoke;
	float filteredMask;

	if (Sharpness >= 0.0)
	{
		// Laplacian sharpening
		float4 albedo_n = SmokeAlbedoTex.Sample(LinearClamp_Sampler, SmokeUV + TexelSize * float2(0, 1));
		float4 albedo_e = SmokeAlbedoTex.Sample(LinearClamp_Sampler, SmokeUV + TexelSize * float2(1, 0));
		float4 albedo_s = SmokeAlbedoTex.Sample(LinearClamp_Sampler, SmokeUV + TexelSize * float2(0, -1));
		float4 albedo_w = SmokeAlbedoTex.Sample(LinearClamp_Sampler, SmokeUV + TexelSize * float2(-1, 0));

		float neighbor = Sharpness * -1.0f;
		float center = Sharpness * 4.0f + 1.0f;
		filteredSmoke = albedo_n * neighbor + albedo_e * neighbor + smokeAlbedoCenter * center + albedo_s * neighbor + albedo_w * neighbor;
		filteredMask = smokeMaskCenter.r;
	}
	else
	{
		// 3x3 Gaussian-like blur
		float4 a0 = SmokeAlbedoTex.Sample(LinearClamp_Sampler, SmokeUV + TexelSize * float2(-1, -1));
		float4 a1 = SmokeAlbedoTex.Sample(LinearClamp_Sampler, SmokeUV + TexelSize * float2( 0, -1));
		float4 a2 = SmokeAlbedoTex.Sample(LinearClamp_Sampler, SmokeUV + TexelSize * float2( 1, -1));
		float4 a3 = SmokeAlbedoTex.Sample(LinearClamp_Sampler, SmokeUV + TexelSize * float2(-1,  0));
		float4 a4 = smokeAlbedoCenter;
		float4 a5 = SmokeAlbedoTex.Sample(LinearClamp_Sampler, SmokeUV + TexelSize * float2( 1,  0));
		float4 a6 = SmokeAlbedoTex.Sample(LinearClamp_Sampler, SmokeUV + TexelSize * float2(-1,  1));
		float4 a7 = SmokeAlbedoTex.Sample(LinearClamp_Sampler, SmokeUV + TexelSize * float2( 0,  1));
		float4 a8 = SmokeAlbedoTex.Sample(LinearClamp_Sampler, SmokeUV + TexelSize * float2( 1,  1));

		float m0 = SmokeMaskTex.Sample(LinearClamp_Sampler, SmokeUV + TexelSize * float2(-1, -1)).r;
		float m1 = SmokeMaskTex.Sample(LinearClamp_Sampler, SmokeUV + TexelSize * float2( 0, -1)).r;
		float m2 = SmokeMaskTex.Sample(LinearClamp_Sampler, SmokeUV + TexelSize * float2( 1, -1)).r;
		float m3 = SmokeMaskTex.Sample(LinearClamp_Sampler, SmokeUV + TexelSize * float2(-1,  0)).r;
		float m4 = smokeMaskCenter.r;
		float m5 = SmokeMaskTex.Sample(LinearClamp_Sampler, SmokeUV + TexelSize * float2( 1,  0)).r;
		float m6 = SmokeMaskTex.Sample(LinearClamp_Sampler, SmokeUV + TexelSize * float2(-1,  1)).r;
		float m7 = SmokeMaskTex.Sample(LinearClamp_Sampler, SmokeUV + TexelSize * float2( 0,  1)).r;
		float m8 = SmokeMaskTex.Sample(LinearClamp_Sampler, SmokeUV + TexelSize * float2( 1,  1)).r;

		float4 blurredAlbedo = (a0 + a2 + a6 + a8) + (a1 + a3 + a5 + a7) * 2.0 + a4 * 4.0;
		blurredAlbedo /= 16.0;

		float blurredMask = (m0 + m2 + m6 + m8) + (m1 + m3 + m5 + m7) * 2.0 + m4 * 4.0;
		blurredMask /= 16.0;

		float blurAmount = saturate(-Sharpness);
		filteredSmoke = lerp(smokeAlbedoCenter, blurredAlbedo, blurAmount);
		filteredMask = lerp(smokeMaskCenter.r, blurredMask, blurAmount);
	}

	// Use filtered values
	float SmokeAlpha = filteredMask;
	float SmokeRayDepth = smokeMaskCenter.g;  // Depth is not filtered (need accurate value)

	// Particle layer (Separate Translucency: premultiplied alpha in RGB, transmittance in A)
	float4 ParticleData = SeparateTranslucencyTex.Sample(LinearClamp_Sampler, TranslucencyUV);
	float3 ParticleColorPremul = ParticleData.rgb;
	float ParticleTransmittance = ParticleData.a;
	float ParticleAlpha = 1.0 - ParticleTransmittance;

	//~======================================================================
	// Calculate Transmittance

	// SmokeAlpha from SmokeMaskTex = opacity (0 = transparent, 1 = opaque)
	// SmokeTransmittance = how much background shows through (1 - alpha)
	float SmokeTransmittance = 1.0 - saturate(SmokeAlpha);

	// HDR burn-through prevention (matching IVSmokeCompositePS.usf)
	// Ray marching early termination (Transmittance > 0.01) can leak HDR
	if (SmokeTransmittance < 0.02)
	{
		SmokeTransmittance = max(0.0, (SmokeTransmittance - 0.01) * 2.0);
	}

	//~======================================================================
	// Depth Comparison
	// SmokeRayDepth = linear distance from camera to first smoke hit (from ray marching)
	// We need to compare this with particle depth.
	//
	// For particles: use CustomDepth if available, convert to linear depth
	// CustomDepth is in device-Z (reversed-Z: 1=near, 0=far), convert using InvDeviceZToWorldZTransform

	// Sample CustomDepth using direct pixel coordinates (Load method - CL 277 style)
	int2 PixelCoord = int2(SvPosition.xy);
	float CustomDeviceZ = SceneTexturesStruct.CustomDepthTexture.Load(int3(PixelCoord, 0)).r;

	// Convert CustomDepth device-Z to linear world depth
	float ParticleLinearDepth = 100000.0;  // Default: very far (no particles)
	if (HasValidCustomDepth(CustomDeviceZ))
	{
		// InvDeviceZToWorldZTransform converts device Z to linear depth
		ParticleLinearDepth = CustomDeviceZ * InvDeviceZToWorldZTransform.x
			+ InvDeviceZToWorldZTransform.y
			+ 1.0 / (CustomDeviceZ * InvDeviceZToWorldZTransform.z - InvDeviceZToWorldZTransform.w);
	}

	// Use smoke ray depth directly (already in linear units)
	float SmokeLinearDepth = SmokeRayDepth;

	// Depth comparison: lower value = closer to camera
	// SmokeInFront = true if smoke is closer than particles
	bool bSmokeInFront = (SmokeLinearDepth > 0.0) && (SmokeLinearDepth < ParticleLinearDepth);

	//~======================================================================
	// Particle presence check (supports both opaque and additive particles)
	// Additive particles have Transmittance = 1.0, so ParticleAlpha = 0
	// Use luminance to detect additive particles that have color but no alpha
	float ParticleLuminance = dot(ParticleColorPremul, float3(0.299, 0.587, 0.114));
	bool bHasParticles = (ParticleAlpha > 0.001) || (ParticleLuminance > 0.001);

	//~======================================================================
	// Composite (pre-multiplied alpha blending)
	//
	// IMPORTANT: In TranslucencyAfterDOF mode, engine composites as:
	//   Final = SceneColor * OutputAlpha + OutputRGB
	//
	// So OutputAlpha = TRANSMITTANCE (0 = opaque, 1 = transparent)
	// And OutputRGB = pre-multiplied color to ADD on top of background
	//
	// We should NOT include SceneColor in OutputRGB - engine handles that!

	float3 FinalColor;
	float FinalTransmittance;

	// No particles case - smoke only
	if (!bHasParticles)
	{
		// Smoke only: RGB = AccumulatedColor (pre-multiplied), A = Transmittance
		FinalColor = filteredSmoke.rgb;
		FinalTransmittance = SmokeTransmittance;
	}
	// No smoke case - particles only
	else if (SmokeAlpha < 0.001)
	{
		// Particles only: RGB = ParticleColorPremul, A = ParticleTransmittance
		FinalColor = ParticleColorPremul;
		FinalTransmittance = ParticleTransmittance;
	}
	// Both smoke and particles - depth-sorted blending
	else
	{
		if (bSmokeInFront)
		{
			// Smoke in front of particles
			// Composite: Smoke OVER Particles (both pre-multiplied)
			// RGB = Smoke + Particles * SmokeTransmittance
			// A   = SmokeTransmittance * ParticleTransmittance (combined transmittance)
			FinalColor = filteredSmoke.rgb + ParticleColorPremul * SmokeTransmittance;
			FinalTransmittance = SmokeTransmittance * ParticleTransmittance;
		}
		else
		{
			// Particles in front of smoke
			// Composite: Particles OVER Smoke (both pre-multiplied)
			// RGB = Particles + Smoke * ParticleTransmittance
			// A   = ParticleTransmittance * SmokeTransmittance (combined transmittance)
			FinalColor = ParticleColorPremul + filteredSmoke.rgb * ParticleTransmittance;
			FinalTransmittance = ParticleTransmittance * SmokeTransmittance;
		}
	}

	OutColor = float4(FinalColor, FinalTransmittance);
}
